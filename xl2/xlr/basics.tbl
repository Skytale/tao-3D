// Basic language features
INFIX(tree,";",tree, SemicolonSequence,
      xl_evaluate(&l);
      RTREE(xl_evaluate(&r)))
INFIX(tree,"\n",tree, NewlineSequence,
      xl_evaluate(&l);
      RTREE(xl_evaluate(&r)))
INFIX(tree,"->", tree, EnterRewrite,
      Symbols::symbols->EnterRewrite(&l,&r);
      RTREE(self))
BLOCK("(", tree, ")", EvaluateParentheses,
      RTREE(xl_evaluate(&child)))
BLOCK(Block::indent, tree, Block::unindent, EvaluateBlock,
      RTREE(xl_evaluate(&child)))

// Integer arithmetic and comparisons
INFIX(integer, "+", integer, BinaryAddInt, RINT(INT(l) + INT(r)))
INFIX(integer, "-", integer, BinarySubInt, RINT(INT(l) - INT(r)))
INFIX(integer, "*", integer, BinaryMulInt, RINT(INT(l) * INT(r)))
INFIX(integer, "/", integer, BinaryDivInt, RINT(INT(l) / INT(r)))
INFIX(integer, "rem", integer, BinaryRemInt, RINT(INT(l) % INT(r)))
INFIX(integer, "mod", integer, BinaryModInt,
      integer_t x = INT(l);
      integer_t y = INT(r);
      integer_t tmp = x % y;
      if (tmp && (x^y) < 0)
          tmp += y;
      RINT(tmp);
      )
INFIX(integer, "^", integer, BinaryPowerInt,
      integer_t x = INT(l);
      integer_t y = INT(r);
      integer_t tmp = 0;
      if (y >= 0)
      {
          tmp = 1;
          while (y)
          {
              if (y & 1)
                  tmp *= x;
              x *= x;
              y >>= 1;
          }
      }
      RINT(tmp);)

INFIX(integer, "<<", integer, BinaryLeftShift, RINT(INT(l) << INT(r)))
INFIX(integer, ">>", integer, BinaryRightShift, RINT(INT(l) >> INT(r)))

INFIX(integer, "and", integer, BinaryAnd, RINT(INT(l) & INT(r)))
INFIX(integer, "or", integer, BinaryOr, RINT(INT(l) | INT(r)))
INFIX(integer, "xor", integer, BinaryXor, RINT(INT(l) ^ INT(r)))

INFIX(integer, "<", integer, BinaryLTInt, RBOOL(INT(l) < INT(r)))
INFIX(integer, ">", integer, BinaryGTInt, RBOOL(INT(l) > INT(r)))
INFIX(integer, "<=", integer, BinaryLEInt, RBOOL(INT(l) <= INT(r)))
INFIX(integer, ">=", integer, BinaryGEInt, RBOOL(INT(l) >= INT(r)))
INFIX(integer, "<>", integer, BinaryNEInt, RBOOL(INT(l) != INT(r)))
INFIX(integer, "=", integer, BinaryEQInt, RBOOL(INT(l) == INT(r)))

PREFIX("-", PARM(x, integer), NegateInt, RINT(-x))
PREFIX("not", PARM(x, integer), NotInt, RINT(~x))
POSTFIX(PARM(x, real), "%", PercentReal, RREAL(x / 100.0))
POSTFIX(PARM(x, integer), "%", PercentInteger, RREAL(x / 100.0))

// Real arithmetic and comparisons
INFIX(real, "+", real, BinaryAddReal, RREAL(REAL(l) + REAL(r)))
INFIX(real, "-", real, BinarySubReal, RREAL(REAL(l) - REAL(r)))
INFIX(real, "*", real, BinaryMulReal, RREAL(REAL(l) * REAL(r)))
INFIX(real, "/", real, BinaryDivReal, RREAL(REAL(l) / REAL(r)))
INFIX(real, "rem", real, BinaryRemReal, RREAL(fmod(REAL(l), REAL(r))))
INFIX(real, "mod", real, BinaryModReal,
      real_t x = REAL(l);
      real_t y = REAL(r);
      real_t tmp = fmod(x,y);
      if (tmp != 0.0 && x*y < 0.0)
          tmp += y;
      RREAL(tmp);)
INFIX(real, "^", integer, BinaryPowRealInt,
      real_t x = REAL(l);
      integer_t y = INT(r);
      boolean_t negative = y < 0;
      real_t tmp = 1.0;
      if (negative) y = -y;
      while (y)
      {
          if (y & 1)
              tmp *= x;
          x *= x;
          y >>= 1;
      }
      if (negative) tmp = 1.0/tmp;
      RREAL(tmp);)
INFIX(real, "^", real, BinaryPowReal, RREAL(pow(REAL(l), REAL(r))))

INFIX(real, "<", real, BinaryLTReal, RBOOL(REAL(l) < REAL(r)))
INFIX(real, ">", real, BinaryGTReal, RBOOL(REAL(l) > REAL(r)))
INFIX(real, "<=", real, BinaryLEReal, RBOOL(REAL(l) <= REAL(r)))
INFIX(real, ">=", real, BinaryGEReal, RBOOL(REAL(l) >= REAL(r)))
INFIX(real, "<>", real, BinaryNEReal, RBOOL(REAL(l) != REAL(r)))
INFIX(real, "=", real, BinaryEQReal, RBOOL(REAL(l) == REAL(r)))

PREFIX("-", PARM(r, real), NegateReal, RREAL(-r))
PREFIX("sin", PARM(x, real), SinReal, RREAL(sin(x)))
PREFIX("cos", PARM(x, real), CosReal, RREAL(cos(x)))
PREFIX("tan", PARM(x, real), TanReal, RREAL(tan(x)))
PREFIX("asin", PARM(x, real), ArcSinReal, RREAL(asin(x)))
PREFIX("acos", PARM(x, real), ArcCosReal, RREAL(acos(x)))
PREFIX("atan", PARM(x, real), ArcTanReal, RREAL(atan(x)))
PREFIX("atan", PARM(y, real) PARM(x, real), ArcTanReal2, RREAL(atan2(y,x)))
PREFIX("exp", PARM(x, real), ExpReal, RREAL(exp(x)))
PREFIX("expm1", PARM(x, real), ExpRealMinus1, RREAL(expm1(x)))
PREFIX("log", PARM(x, real), LogReal, RREAL(log(x)))
PREFIX("log2", PARM(x, real), Log2Real, RREAL(log2(x)))
PREFIX("log10", PARM(x, real), Log10Real, RREAL(log10(x)))
PREFIX("log1p", PARM(x, real), LogPlus1Real, RREAL(log1p(x)))
PREFIX("pi", , PiConstant, RREAL(M_PI))

// Boolean operations
INFIX(boolean, "and", boolean, BinaryAndBool, RBOOL(BOOL(l) & BOOL(r)))
INFIX(boolean, "or", boolean, BinaryOrBool, RBOOL(BOOL(l) | BOOL(r)))
INFIX(boolean, "xor", boolean, BinaryXorBool, RBOOL(BOOL(l) ^ BOOL(r)))
PREFIX("not", PARM(x, boolean), NotBool, RBOOL(!x))

INFIX(boolean, "<>", boolean, BinaryNEBool, RBOOL(BOOL(l) != BOOL(r)))
INFIX(boolean, "=", boolean, BinaryEQBool, RBOOL(BOOL(l) == BOOL(r)))

// Text operations
INFIX(text, "&", text, BinaryTextConcatenate, RTEXT(TEXT(l) + TEXT(r)))
INFIX(text, "<", text, BinaryLTText, RBOOL(TEXT(l) < TEXT(r)))
INFIX(text, ">", text, BinaryGTText, RBOOL(TEXT(l) > TEXT(r)))
INFIX(text, "<=", text, BinaryLEText, RBOOL(TEXT(l) <= TEXT(r)))
INFIX(text, ">=", text, BinaryGEText, RBOOL(TEXT(l) >= TEXT(r)))
INFIX(text, "<>", text, BinaryNEText, RBOOL(TEXT(l) != TEXT(r)))
INFIX(text, "=", text, BinaryEQText, RBOOL(TEXT(l) == TEXT(r)))


// Conversions
PREFIX("real", PARM(x, integer), IntToReal, RREAL((real_t) x))
PREFIX("integer", PARM(x, real), RealToInt, RINT((integer_t) x))
PREFIX("text", PARM(x, integer), IntToText,
       std::ostringstream out; out << x; RTEXT(out.str()))
PREFIX("text", PARM(x, real), RealToText,
       std::ostringstream out; out << x; RTEXT(out.str()))

// Time computations
PREFIX("system_time",,    SystemTime,    time_t t; time(&t); RINT(t))
PREFIX("hours", PARM(t, integer),   TimeHours,
       struct tm tm; time_t clock = t;
       localtime_r(&clock, &tm); RINT(tm.tm_hour))
PREFIX("minutes", PARM(t, integer), TimeMinutes,
       struct tm tm; time_t clock = t;
       localtime_r(&clock, &tm); RINT(tm.tm_min))
PREFIX("seconds", PARM(t, integer), TimeSeconds,
       struct tm tm; time_t clock = t;
       localtime_r(&clock, &tm); RINT(tm.tm_sec))
PREFIX("year", PARM(t, integer), TimeYear,
       struct tm tm; time_t clock = t;
       localtime_r(&clock, &tm); RINT(tm.tm_year + 1900))
PREFIX("month", PARM(t, integer), TimeMonth,
       struct tm tm; time_t clock = t;
       localtime_r(&clock, &tm); RINT(tm.tm_mon))
PREFIX("day", PARM(t, integer), TimeMonthDay,
       struct tm tm; time_t clock = t;
       localtime_r(&clock, &tm); RINT(tm.tm_mday))
PREFIX("week_day", PARM(t, integer), TimeWeekDay,
       struct tm tm; time_t clock = t;
       localtime_r(&clock, &tm); RINT(tm.tm_wday))
PREFIX("year_day", PARM(t, integer), TimeYearDay,
       struct tm tm; time_t clock = t;
       localtime_r(&clock, &tm); RINT(tm.tm_yday))

// Return hour, minutes, seconds
PREFIX("hours",,   SystemHours,
       time_t t; struct tm tm;
       time (&t); localtime_r(&t, &tm); RINT(tm.tm_hour))
PREFIX("minutes",, SystemMinutes,
       time_t t; struct tm tm;
       time (&t); localtime_r(&t, &tm); RINT(tm.tm_min))
PREFIX("seconds",, SystemSeconds,
       time_t t; struct tm tm;
       time (&t); localtime_r(&t, &tm); RINT(tm.tm_sec))
PREFIX("year",, SystemYear,
       time_t t; struct tm tm;
       time (&t); localtime_r(&t, &tm); RINT(tm.tm_year + 1900))
PREFIX("month",, SystemMonth,
       time_t t; struct tm tm;
       time (&t); localtime_r(&t, &tm); RINT(tm.tm_mon))
PREFIX("day",, SystemMonthDay,
       time_t t; struct tm tm;
       time (&t); localtime_r(&t, &tm); RINT(tm.tm_mday))
PREFIX("week_day",, SystemWeekDay,
       time_t t; struct tm tm;
       time (&t); localtime_r(&t, &tm); RINT(tm.tm_wday))
PREFIX("year_day",, SystemYearDay,
       time_t t; struct tm tm;
       time (&t); localtime_r(&t, &tm); RINT(tm.tm_yday))

// Random number generator
PREFIX("random", , RandomNumber, RREAL(drand48()))
PREFIX("random", PARM(low, real) PARM(high, real),
       RandomNumber2, RREAL(drand48() * (high - low) + low))
PREFIX("random", PARM(low, integer) PARM(high, integer),
       RandomNumber2i, RINT((longlong) (drand48() * (high - low) + low)))

// Executing some code
PREFIX("do", PARM(code, tree), DoCode, return xl_evaluate(&code))
PREFIX("load", PARM(file, text), LoadFile, return xl_load(file))
PREFIX("load_csv", PARM(file, text), LoadCSVFile, return xl_load_csv(file))
PREFIX("load_tsv", PARM(file, text), LoadTSVFile, return xl_load_tsv(file))

// Debugging code
PREFIX("debug", PARM(toDebug, tree), DebugTree,
       std::cerr << "DEBUG: " << (Tree *) &toDebug << "\n"; return &toDebug)

// Compute the sha1 of a tree
PREFIX("sha1", PARM(t, tree), ComputeSha1, RTEXT(sha1(&t)))

NAME(nil);
NAME(true);
NAME(false);

TYPE(boolean);
TYPE(integer);
TYPE(real);
TYPE(text);
TYPE(character);
TYPE(tree);
TYPE(symbolicname);
TYPE(infix);
TYPE(prefix);
TYPE(postfix);
TYPE(block);
