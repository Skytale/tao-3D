/*start*/
// ****************************************************************************
//  graphics.tbl                                                    Tao project
// ****************************************************************************
//
//   File Description:
//
//     List of basic entry points used to create Tao documents
//
//
//
//
//
//
//
//
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html and Matthew 25:22 for details
//  (C) 1992-2010 Christophe de Dinechin <christophe@taodyne.com>
//  (C) 2010 Lionel Schaffhauser <lionel@taodyne.com>
//  (C) 2010 Catherine Burvelle <catherine@todyne.com>
//  (C) 2010 Taodyne SAS
// ****************************************************************************

// ============================================================================
//
// Getting attributes
//
// ============================================================================

PREFIX(Page,  text,  "page",
    PARM(n, text, "The name of the page. [TODO ddd: What's happen if the name is not unique in the document ?]")
    PARM(b, tree, "The content of the page.")
, RTAO(page(self,n,b)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("Create a new page."),
    DOC_DESCRIPTION("Create a new page in the document with the specified name and content."),
    DOC_RET( text, "The name of the previously named page"), )
PREFIX(PageLink,  text,  "page_link",
    PARM(k, text, "The key name.")
    PARM(n, text, "The name of the page to link")
, RTAO(pageLink(self, k, n)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("Indicate the chaining of pages."),
    DOC_DESCRIPTION("Links the key with the named page."),
    DOC_RET( text, "The name of the page previously linked to this key."), )
PREFIX(GotoPage,  text,  "goto_page",
    PARM(p, text, "")
, RTAO(gotoPage(self, p)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("Directly go to the given page."),
    DOC_DESCRIPTION("Directly go to the given page."),
    DOC_RET( text, "The name of the previously shown page."), )

PREFIX(PageLabel,    text,      "page_label", , RTAO(pageLabel(self)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("The current page name."),
    DOC_DESCRIPTION("Return the current page name"),
    DOC_RET(   text, "Return the label of the current page"), )
PREFIX(PageId,       integer,   "page_number", , RTAO(pageNumber(self)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("The current page number"),
    DOC_DESCRIPTION("Return the number of the current page"),
    DOC_RET(      integer, "Return the number of the current page"), )
PREFIX(PageCount,    integer,   "page_count", , RTAO(pageCount(self)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("The number of page."),
    DOC_DESCRIPTION("Return the number of pages in the current document"),
    DOC_RET(   integer, "Return the number of pages in the current document"), )
PREFIX(PageWidth,    real,      "page_width", , RTAO(pageWidth(self)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("Return the width of pages"),
    DOC_DESCRIPTION("Return the width of pages"),
    DOC_RET(   real, "Return the width of pages"), )
PREFIX(PageHeight,   real,      "page_height", , RTAO(pageHeight(self)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("Return the height of pages"),
    DOC_DESCRIPTION("Return the height of pages"),
    DOC_RET(  real, "Return the height of pages"), )

PREFIX(PagePrintTime,  real,  "page_print_time",
    PARM(t, real, )
, RTAO(pageSetPrintTime(self, t)),
    DOC_GROUP(page),
    DOC_SYNOPSIS("Set the freeze time used when printing."),
    DOC_DESCRIPTION("Set the time used when printing pages"),
    DOC_RET( real, "Previous time used for printing"), )

PREFIX(FrameWidth,   real,      "frame_width", , RTAO(frameWidth(self)),
    DOC_GROUP(frame),
    DOC_SYNOPSIS("Return the width of the current layout frame"),
    DOC_DESCRIPTION("Return the width of the current layout frame"),
    DOC_RET(  real, "Return the width of the current layout frame"), )
PREFIX(FrameHeight,  real,      "frame_height", , RTAO(frameHeight(self)),
    DOC_GROUP(frame),
    DOC_SYNOPSIS("Return the height of the current layout frame"),
    DOC_DESCRIPTION("Return the height of the current layout frame"),
    DOC_RET( real, "Return the height of the current layout frame"), )
PREFIX(FrameDepth,   real,      "frame_depth", , RTAO(frameDepth(self)),
    DOC_GROUP(frame),
    DOC_SYNOPSIS("Return the depth of the current layout frame"),
    DOC_DESCRIPTION("Return the depth of the current layout frame"),
    DOC_RET(  real, "Return the depth of the current layout frame"), )
PREFIX(WindowWidth,  real,      "window_width", , RTAO(windowWidth(self)),
    DOC_GROUP(window),
    DOC_SYNOPSIS("Return the width of the window in which we display"),
    DOC_DESCRIPTION("Return the width of the window in which we display"),
    DOC_RET( real, "Return the width of the window in which we display"), )
PREFIX(WindowHeight, real,      "window_height", , RTAO(windowHeight(self)),
    DOC_GROUP(window),
    DOC_SYNOPSIS("Return the height of window in which we display"),
    DOC_DESCRIPTION("Return the height of window in which we display"),
    DOC_RET(real, "Return the height of window in which we display"), )
PREFIX(DaySeconds,   real,      "time", , RTAO(time(self)),
    DOC_GROUP(time),
    DOC_SYNOPSIS("Return a fractional time, including milliseconds"),
    DOC_DESCRIPTION("Returns the current document's time or the time at wich the document was frozen."),
    DOC_RET(  real, "Return a fractional time, including milliseconds"), )
PREFIX(PageSeconds,  real,      "page_time", , RTAO(pageTime(self)),
    DOC_GROUP(time),
    DOC_SYNOPSIS("Returns the page time"),
    DOC_DESCRIPTION("Returns the time of the current page relatively to the current document's time, or relatively to the frozen time."),
    DOC_RET( real, "Return a fractional time, including milliseconds"), )
PREFIX(After,        real,      "after",
    PARM(d, real, "The delay in second. Sensitive upto millisecond.")
    PARM(c, tree, "The code to execute.")
, RTAO(after(self, d, c)),
    DOC_GROUP(time),
    DOC_SYNOPSIS("Wait for time to execute code"),
    DOC_DESCRIPTION("Execute the given code only after the specified amount of time."),
    DOC_RET(       real, "The real elapsed time."), )
PREFIX(Every,        real,      "every",
    PARM(i, real, )
    PARM(d, real, )
    PARM(c, tree, )
, RTAO(every(self, i, d, c)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(Every50Pct,   real,      "every",
    PARM(i, real, "[TODO ddd: Explication...]")
    PARM(c, tree, "[TODO ddd: Explication...]. If not given the default value is 0.5")
, RTAO(every(self, i, 0.5, c)),
    DOC_GROUP(time),
    DOC_SYNOPSIS("Code executed every interval."),
    DOC_DESCRIPTION("[TODO ddd: Explication...]"),
    DOC_RET(  real, "The real elapsed time."), )

PREFIX(MouseX,  real,  "mouse_x", , RTAO(mouseX(self)),
    DOC_GROUP(mouse),
    DOC_SYNOPSIS("Mouse x-coordinate"),
    DOC_DESCRIPTION("Mouse x-coordinate"),
    DOC_RET( real, "Return the position of the mouse"), )
PREFIX(MouseY,  real,  "mouse_y", , RTAO(mouseY(self)),
    DOC_GROUP(mouse),
    DOC_SYNOPSIS("Mouse y-coordinate"),
    DOC_DESCRIPTION("Mouse y-coordinate"),
    DOC_RET( real, "Return the position of the mouse"), )
PREFIX(MouseButtons,  integer,  "mouse_buttons", , RTAO(mouseButtons(self)),
    DOC_GROUP(mouse),
    DOC_SYNOPSIS("Return the buttons of the last mouse event"),
    DOC_DESCRIPTION("Return the buttons of the last mouse event. It is an OR combination of following values:\n\
Qt::NoButton	0x00000000	The button state does not refer to any button (see QMouseEvent::button()).\n\
Qt::LeftButton	0x00000001	The left button is pressed, or an event refers to the left button. (The left button may be the right button on left-handed mice.)\n\
Qt::RightButton	0x00000002	The right button.\n\
Qt::MidButton	0x00000004	The middle button.\n\
Qt::XButton1	0x00000008	The first X button.\n\
Qt::XButton2	0x00000010	The second X button.\n\
"),
    DOC_RET( integer, "Return the buttons of the last mouse event"), )
PREFIX(ShapeAction,  tree,  "on",
    PARM(n,text, "The action name")
    PARM(t,tree, "The code to execute")
, RTAO(shapeAction(self,n,t)),
    DOC_GROUP(mouse),
    DOC_SYNOPSIS("Associate the specified code to the named action."),
    DOC_DESCRIPTION("Associate the specified code to the named action. This code is then executed when the action occurs on the current shape."),, )
PREFIX(ShapeClickAction,  tree,  "on_click",
    PARM(t,tree, "The code to execute")
, RTAO(shapeAction(self,"click",t)),
    DOC_GROUP(mouse),
    DOC_SYNOPSIS("Associate code with click."),
    DOC_DESCRIPTION("Associate the specified code to the click"),, )
PREFIX(ShapeMouseoverAction,  tree,  "on_mouseover",
    PARM(t,tree, "The code to execute")
, RTAO(shapeAction(self,"mouseover",t)),
    DOC_GROUP(mouse),
    DOC_SYNOPSIS("Associate code with mouse over"),
    DOC_DESCRIPTION("Associate the specified code to the mouse over"),, )



// ============================================================================
//
// Preserving attributes
//
// ============================================================================

PREFIX(Locally,  tree,  "locally",
    PARM(t, tree, "The code to execute in a local context")
, RTAO(locally(self, t)),
    DOC_GROUP(code),
    DOC_SYNOPSIS("Make a local context"),
    DOC_DESCRIPTION("Evaluate the child tree while preserving the current state"),
    DOC_RET( tree, "The result of the child execution."), )
PREFIX(Shape,    tree,  "shape",
    PARM(t, tree, "The code of the shape.")
, RTAO(shape(self, t)),
    DOC_GROUP(code:graph),
    DOC_SYNOPSIS("Make the shape selectable"),
    DOC_DESCRIPTION("Evaluate the child and mark the current shape. Make the shape sensible to mosue events like selection, motion, rotation..."),
    DOC_RET(   tree, "The result of the child execution."), )
PREFIX(Widget,   tree,  "active_widget",
    PARM(t,tree, "The code that represent the widget.")
, RTAO(activeWidget(self,t)),
    DOC_GROUP(code:graph:widget),
    DOC_SYNOPSIS("Make the widget clickable"),
    DOC_DESCRIPTION("Create a context for active widgets, e.g. buttons"),
    DOC_RET(  tree, "The result of the child execution."), )
PREFIX(Anchor,   tree,  "anchor",
    PARM(t, tree, "The code that represent the shapes to be anchored.")
, RTAO(anchor(self, t)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION("Anchor a set of shapes to the current position"),
    DOC_RET(  tree, "The result of the child execution."), )



// ============================================================================
//
//   Transforms
//
// ============================================================================

PREFIX(ResetTransform,  tree,  "reset_transform", , RTAO(resetTransform(self)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Reset transform"),
    DOC_DESCRIPTION("Reset transform to original projection state."),, )

PREFIX(RotateX,  tree,  "rotatex",
    PARM(rx, real, "The angle of rotation in degree.[TODO : check the unit]")
, RTAO(rotatex(self, rx)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Rotate around X"),
    DOC_DESCRIPTION("Rotate around X axis."),, )
PREFIX(RotateY,  tree,  "rotatey",
    PARM(ry, real, "The angle of rotation in degree.[TODO : check the unit]")
, RTAO(rotatey(self, ry)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Rotate around Y"),
    DOC_DESCRIPTION("Rotate around Y axis."),, )
PREFIX(RotateZ,  tree,  "rotatez",
    PARM(rz, real, "The angle of rotation in degree.[TODO : check the unit]")
, RTAO(rotatez(self, rz)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Rotate around Z"),
    DOC_DESCRIPTION("Rotate around Z axis."),, )
PREFIX(Rotate,  tree,  "rotate",
    PARM(ra, real, "[TODO : A-t-on une rotation autour de l'axe du temps ???]")
    PARM(rx, real, "angle around X-axis")
    PARM(ry, real, "angle around Y-axis")
    PARM(rz, real, "angle around Z-axis")
, RTAO(rotate(self, ra, rx, ry, rz)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Rotation"),
    DOC_DESCRIPTION("Rotation along an arbitrary axis"),, )

PREFIX(TransX,  tree,  "translatex",
    PARM(x, real, "x translation.")
, RTAO(translatex(self, x)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Translate along X"),
    DOC_DESCRIPTION("Translate along X-axis"),, )
PREFIX(TransY,  tree,  "translatey",
    PARM(y, real, "y translation.")
, RTAO(translatey(self, y)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Translate along Y"),
    DOC_DESCRIPTION("Translate along Y-axis"),, )
PREFIX(TransZ,  tree,  "translatez",
    PARM(z, real, "z translation.")
, RTAO(translatez(self, z)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Translate along Z"),
    DOC_DESCRIPTION("Translate along Z-axis"),, )
PREFIX(Translate,  tree,  "translate",
    PARM(x, real, "x translation.")
    PARM(y, real, "y translation.")
    PARM(z, real, "z translation.")
, RTAO(translate(self, x, y, z)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Translation along three axes"),
    DOC_DESCRIPTION("Translation along three axes"),, )

PREFIX(ScaleX,  tree,  "scalex",
    PARM(x, real, "scale factor.")
, RTAO(rescalex(self, x)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Rescale along X"),
    DOC_DESCRIPTION("Rescale along X-axis"),, )
PREFIX(ScaleY,  tree,  "scaley",
    PARM(y, real, "scale factor.")
, RTAO(rescaley(self, y)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Rescale along Y"),
    DOC_DESCRIPTION("Rescale along Y-axis"),, )
PREFIX(ScaleZ,  tree,  "scalez",
    PARM(z, real, "scale factor.")
, RTAO(rescalez(self, z)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Rescale along Z"),
    DOC_DESCRIPTION("Rescale along Z-axis"),, )
PREFIX(Scale,  tree,  "scale",
    PARM(x, real, "x-scale factor.")
    PARM(y, real, "y-scale factor.")
    PARM(z, real, "z-scale factor.")
, RTAO(rescale(self, x, y, z)),
    DOC_GROUP(graph:transform),
    DOC_SYNOPSIS("Scaling along three axes"),
    DOC_DESCRIPTION("Scaling along three axes"),, )



// ============================================================================
//
//    Setting attributes
//
// ============================================================================

PREFIX(EnableDepthTest,  boolean,  "enable_depth_test", , RTAO(depthTest(self, true)),
    DOC_GROUP(code:graph),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(" [TODO : Je ne vois pas vraiment...] "),, )
PREFIX(DisableDepthTest,  boolean,  "disable_depth_test", , RTAO(depthTest(self, false)),
    DOC_GROUP(code:graph),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION("[TODO : Je ne vois pas vraiment...]"),, )
PREFIX(Refresh,  tree,  "refresh",
    PARM(d, real, "The delay to wait.")
, RTAO(refresh(self, d)),
    DOC_GROUP(code:graph:time),
    DOC_SYNOPSIS("Refresh after d second"),
    DOC_DESCRIPTION("Refresh the screen after the given time interval"),
    DOC_RET( tree, ""), )
PREFIX(ShowSource,  boolean,  "show_source",
    PARM(an, boolean, "Show the source pane if true.")
, RTAO(showSource(self, an)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Source pane view"),
    DOC_DESCRIPTION("Show or hide the source pane."),
    DOC_RET( boolean, ""), )
PREFIX(FullScreen,  boolean,  "full_screen",
    PARM(fs, boolean, "on or off")
, RTAO(fullScreen(self, fs)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Switch to full screen"),
    DOC_DESCRIPTION("Set the full screen mode"),
    DOC_RET( boolean, ""), )
PREFIX(ToggleFullScreen,  boolean,  "toggle_full_screen", , RTAO(toggleFullScreen(self)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Toggle the full screen mode"),
    DOC_DESCRIPTION("Toggle the full screen mode"),, )
PREFIX(AutoHideCursor,  boolean,  "auto_hide_cursor",
    PARM(autoHide, boolean, "on or off")
, RTAO(autoHideCursor(self, autoHide)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Enable or disable cursor auto-hide"),
    DOC_DESCRIPTION("Enable ior disable cursor auto-hide"),
    DOC_RET( boolean, ""), )
PREFIX(ToggleAutoHideCursor,  boolean,  "toggle_auto_hide_cursor", , RTAO(toggleAutoHideCursor(self)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Toggle the cursor auto-hide mode"),
    DOC_DESCRIPTION("Toggle the cursor auto-hide mode"),, )
PREFIX(SlideShow,  boolean,  "slide_show",
    PARM(ss, boolean, "on or off")
, RTAO(slideShow(self, ss)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Switch to slide show mode"),
    DOC_DESCRIPTION("Set the slide show mode"),
    DOC_RET( boolean, ""), )
PREFIX(ToggleSlideShow,  boolean,  "toggle_slide_show", , RTAO(toggleSlideShow(self)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Toggle the slide show mode"),
    DOC_DESCRIPTION("Toggle the slide show mode"),, )
PREFIX(ResetView,  boolean,  "reset_view", , RTAO(resetView(self)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Reset view to default parameters"),
    DOC_DESCRIPTION("Restore default view parameters (zoom, position etc.)"),, )
PREFIX(PanEye,  boolean,  "pan",
    PARM(dx, real, "value for x-axis")
    PARM(dy, real, "value for y-axis")
, RTAO(panView(self,dx,dy)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Pan the current view by the current amount"),
    DOC_DESCRIPTION("Pan the current view by the current amount in x and y axis"),, )
PREFIX(GetZoom,  real,  "zoom", , RTAO(currentZoom(self)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(SetZoom,  boolean,  "zoom",
    PARM(z, real, "the zoom factor")
, RTAO(setZoom(self, z)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("zoom manipulation"),
    DOC_DESCRIPTION("Set the zoom level"),
    DOC_RET( boolean, "the current zoom factor"), )
PREFIX(GetEye,  infix,  "eye_position", , RTAO(currentEyePosition(self)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(SetEye,  boolean,  "eye_position",
    PARM(x, real, "eye position on x-axis")
    PARM(y, real, "eye position on y-axis")
    PARM(z, real, )
, RTAO(setEyePosition(self, x, y, z)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("eye position manipulation"),
    DOC_DESCRIPTION("Set the eye position value."),
    DOC_RET( boolean, "(x,y) :the current eye position."), )
PREFIX(GetCenter,  infix,  "center_position", , RTAO(currentCenterPosition(self)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(SetCenter,  boolean,  "center_position",
    PARM(x, real, "eye position on x-axis")
    PARM(y, real, "eye position on y-axis")
    PARM(z, real, )
, RTAO(setCenterPosition(self, x, y, z)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Center position management"),
    DOC_DESCRIPTION("Set the current center position"),
    DOC_RET( boolean, "(x,y) : the current center position"), )
PREFIX(ToggleHandCursor,  boolean,  "toggle_hand_cursor", , RTAO(toggleHandCursor(self)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Switch between hand and arrow cursor"),
    DOC_DESCRIPTION("Switch between hand and arrow cursor"),
    DOC_RET( boolean, ""), )
PREFIX(KeyboardModifiers,  integer,  "keyboard_modifiers", , RTAO(lastModifiers(self)),
    DOC_GROUP(code),
    DOC_SYNOPSIS("Get the current modifiers"),
    DOC_DESCRIPTION("Get the current keyboard modifiers. The value is an OR combination of the following :\n\
Qt::NoModifier	0x00000000	No modifier key is pressed.\n\
Qt::ShiftModifier	0x02000000	A Shift key on the keyboard is pressed.\n\
Qt::ControlModifier	0x04000000	A Ctrl key on the keyboard is pressed.\n\
Qt::AltModifier	0x08000000	An Alt key on the keyboard is pressed.\n\
Qt::MetaModifier	0x10000000	A Meta key on the keyboard is pressed.\n\
Qt::KeypadModifier	0x20000000	A keypad button is pressed.\n\
Qt::GroupSwitchModifier	0x40000000	X11 only. A Mode_switch key on the keyboard is pressed.\n\
Note: On Mac OS X, the ControlModifier value corresponds to the Command keys on the Macintosh keyboard, and the MetaModifier value corresponds to the Control keys. The KeypadModifier value will also be set when an arrow key is pressed as the arrow keys are considered part of the keypad.\n\
Note: On Windows Keyboards, Qt::MetaModifier and Qt::Key_Meta are mapped to the Windows key."),
    DOC_RET( integer, "Return the current modifiers"), )
PREFIX(EnableAnimations,  boolean,  "enable_animations",
    PARM(an, boolean, "on or off")
, RTAO(enableAnimations(self, an)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Enable or disable animations"),
    DOC_DESCRIPTION("Enable or disable animations"),
    DOC_RET( boolean, "True if previous state was on."), )
PREFIX(EnableStereoscopy,  boolean,  "enable_stereoscopy",
    PARM(mode, symbol, "on or off")
, RTAO(enableStereoscopy(self, mode)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Enable or disable stereoscopie mode"),
    DOC_DESCRIPTION("Enable or disable stereoscopie mode"),
    DOC_RET( boolean, "True if previous state was on."), )
PREFIX(EyeDistance,  boolean,  "eye_distance",
    PARM(e, real, )
, RTAO(setEyeDistance(self, e)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(GetEyeDistance,  real,  "eye_distance", , RTAO(getEyeDistance(self)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(ZNear,  boolean,  "z_near",
    PARM(zn, real, )
, RTAO(setZNear(self, zn)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(GetZNear,  real,  "z_near", , RTAO(getZNear(self)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(ZFar,  boolean,  "z_far",
    PARM(zf, real, )
, RTAO(setZFar(self, zf)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(GetZFar,  real,  "z_far", , RTAO(getZFar(self)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(PolygonOffset,  integer,  "polygon_offset",
    PARM(f0, real, "factor base")
    PARM(f1, real, "factor increment")
    PARM(u0, real, "unit base")
    PARM(u1, real, "unit increment")
, RTAO(polygonOffset(self, f0, f1, u0, u1)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("Set the polygon offset factors"),
    DOC_DESCRIPTION("Set the polygon offset factors"),
    DOC_RET( integer, "the current polygon offset"), )



// ============================================================================
//
//    Graphic attributes
//
// ============================================================================

PREFIX(LineColorName,  tree,  "line_color",
    PARM(n, text, "The name of the color, which can be one of the SVG color keywork names, or in one of these formats: #RGB or #RRGGBB  (each of R, G, and B being a single hex digit).")
    PARM(a, real, "The red component of an color, is in the range 0.0 to 1.0.")
, RTAO(lineColorName(self, n, a)),
    DOC_GROUP(graph:attribute),
    DOC_SYNOPSIS("Set the line color"),
    DOC_DESCRIPTION("Set the color for lines."),, )
PREFIX(LineColorRGB,  tree,  "line_color",
    PARM(r, real, )
    PARM(g, real, )
    PARM(b, real, )
    PARM(a, real, )
, RTAO(lineColorRgb(self, r, g, b, a)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(LineColorHSL,  tree,  "line_color_hsl",
    PARM(h, real, )
    PARM(s, real, )
    PARM(l, real, )
    PARM(a, real, )
, RTAO(lineColorHsl(self, h, s, l, a)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(LineColorHSV,  tree,  "line_color_hsv",
    PARM(h, real, )
    PARM(s, real, )
    PARM(v, real, )
    PARM(a, real, )
, RTAO(lineColorHsv(self, h, s, v, a)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(LineColorCMYK,  tree,  "line_color_cmyk",
    PARM(c, real, )
    PARM(m, real, )
    PARM(y, real, )
    PARM(k, real, )
    PARM(a, real, )
, RTAO(lineColorCmyk(self, c, m, y, k, a)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(LineWidth,  tree,  "line_width",
    PARM(lw, real, "The line width to set.")
, RTAO(lineWidth(self, lw)),
    DOC_GROUP(graph:attribute),
    DOC_SYNOPSIS("Select the line width for OpenGL"),
    DOC_DESCRIPTION("Set the line width for OpenGL"),, )
PREFIX(LineStipple,  tree,  "line_stipple",
    PARM(p, integer, "pattern [TODO: which value to which pattern ?]")
    PARM(s, integer, "scale")
, RTAO(lineStipple(self, p, s)),
    DOC_GROUP(graph:attribute),
    DOC_SYNOPSIS("line stipple pattern"),
    DOC_DESCRIPTION("Select the line stipple pattern for OpenGL"),, )
PREFIX(FillColorName,  tree,  "color",
    PARM(n, text, "The name of the color, which can be one of the SVG color keywork names, or in one of these formats: #RGB or #RRGGBB  (each of R, G, and B being a single hex digit).")
    PARM(a, real, "The red component of an color, is in the range 0.0 to 1.0.")
, RTAO(fillColorName(self, n, a)),
    DOC_GROUP(graph:attribute),
    DOC_SYNOPSIS("Set the fill color"),
    DOC_DESCRIPTION("Set the color for fill."),, )
PREFIX(FillColorRGB,  tree,  "color",
    PARM(r, real, )
    PARM(g, real, )
    PARM(b, real, )
    PARM(a, real, )
, RTAO(fillColorRgb(self, r, g, b, a)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(FillColorHSL,  tree,  "color_hsl",
    PARM(h, real, )
    PARM(s, real, )
    PARM(l, real, )
    PARM(a, real, )
, RTAO(fillColorHsl(self, h, s, l, a)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(FillColorHSV,  tree,  "color_hsv",
    PARM(h, real, )
    PARM(s, real, )
    PARM(v, real, )
    PARM(a, real, )
, RTAO(fillColorHsv(self, h, s, v, a)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(FillColorCMYK,  tree,  "color_cmyk",
    PARM(c, real, )
    PARM(m, real, )
    PARM(y, real, )
    PARM(k, real, )
    PARM(a, real, )
, RTAO(fillColorCmyk(self, c, m, y, k, a)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(FillTexture,  tree,  "texture",
    PARM(n, text, "The image filename.")
, RTAO(fillTexture(self, n)),
    DOC_GROUP(graph:attribute),
    DOC_SYNOPSIS("Create a GL texture"),
    DOC_DESCRIPTION("Build a GL texture out of an image file. Supported format are:\n\
BMP	Windows Bitmap\n\
GIF	Graphic Interchange Format (optional)\n\
JPG	Joint Photographic Experts Group\n\
JPEG	Joint Photographic Experts Group\n\
PNG	Portable Network Graphics\n\
PBM	Portable Bitmap\n\
PGM	Portable Graymap\n\
PPM	Portable Pixmap\n\
TIFF	Tagged Image File Format\n\
XBM	X11 Bitmap\n\
XPM	X11 Pixmap"),, )
PREFIX(FillTextureSVG,  tree, "svg",
    PARM(img, text, "The image filename.")
, RTAO(fillTextureFromSVG(self, img)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("Create a texture from an SVG"),
    DOC_DESCRIPTION("Draw an image from an SVG format"),
    DOC_RET( tree, ""), )
PREFIX(FillAnimatedTexture,  tree,  "animated_texture",
    PARM(n, text, "The animation filename.")
, RTAO(fillAnimatedTexture(self, n)),
    DOC_GROUP(graph:attribute),
    DOC_SYNOPSIS("Create a GL animated texture"),
    DOC_DESCRIPTION("Build a GL texture images from an animated image file. Supported format are:\n\
GIF	Animated Graphic Interchange Format\n\
MNG	Animated portable Network Graphics\n\
others [TODO:  description is troncated] "),, )
PREFIX(ImageA,  tree, "image",
    PARM(x, real, )
    PARM(y, real, )
    PARM(w, real, )
    PARM(h, real, )
    PARM(img, text, )
, RTAO(image(self, x, y, w, h, img)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(ImageB,  tree, "image",
    PARM(x, real, "x-coordinate of the image")
    PARM(y, real, "y-coordinate of the image")
    PARM(img, text, "width of the image")
, RTAO(image(self, x, y, img)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("Make an image"),
    DOC_DESCRIPTION("Make an image. image x,y,img rewrites the source with image x,y,w,h,img where w and h are the original size of the image."),, )
PREFIX(TextureWrap,  tree,  "texture_wrap",
    PARM(s, boolean, "[TODO]")
    PARM(t, boolean, "[TODO]")
, RTAO(textureWrap(self, s, t)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("wrap textures or clamp them"),
    DOC_DESCRIPTION("Record if we want to wrap textures or clamp them"),, )
PREFIX(TextureTransform,  tree,  "texture_transform",
    PARM(t, tree, "[TODO]")
, RTAO(textureTransform(self, t)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("Apply a texture transformation"),
    DOC_DESCRIPTION("Apply a texture transformation.[TODO: de quel genre ?]"),
    DOC_RET( tree, "The result of the child evaluation."), )



// ============================================================================
//
//   Generating a path
//
// ============================================================================

PREFIX(Path,    tree,  "path",
    PARM(t, tree, "The definition of the path.")
, RTAO(newPath(self, t)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("Start a path"),
    DOC_DESCRIPTION("Evaluate the child tree within a polygon"),
    DOC_RET(   tree, "The result of the child evaluation."), )
PREFIX(MoveTo,  tree,  "move_to",
    PARM(x, real, "x-coordinate of the point to move to.")
    PARM(y, real, "y-coordinate of the point to move to.")
    PARM(z, real, "z-coordinate of the point to move to.")
, RTAO(moveTo(self, x, y, z)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("move to point"),
    DOC_DESCRIPTION("Add a 'moveTo' to the current path"),, )
PREFIX(LineTo,  tree,  "line_to",
    PARM(x, real, "x-coordinate of the point to line to.")
    PARM(y, real, "y-coordinate of the point to line to.")
    PARM(z, real, "z-coordinate of the point to line to.")
, RTAO(lineTo(self, x, y, z)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("line to point"),
    DOC_DESCRIPTION("Add a 'lineTo' to the current path"),, )
PREFIX(QuadTo,  tree,  "quad_to",
    PARM(cx, real, "x-coordinate of the control point.")
    PARM(cy, real, "y-coordinate of the control point.")
    PARM(cz, real, "z-coordinate of the control point.")
    PARM(x, real, "x-coordinate of the point to finish to.")
    PARM(y, real, "y-coordinate of the point to finish to.")
    PARM(z, real, "z-coordinate of the point to finish to.")
, RTAO(curveTo(self, cx, cy, cz, x, y, z)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS(" quadric curveTo"),
    DOC_DESCRIPTION("Add a quadric curveTo to the current path."),, )
PREFIX(CubicTo,  tree,  "cubic_to",
    PARM(c1x, real, "x-coordinate of the first control point.")
    PARM(c1y, real, "y-coordinate of the first control point.")
    PARM(c1z, real, "z-coordinate of the first control point.")
    PARM(c2x, real, "x-coordinate of the second control point.")
    PARM(c2y, real, "y-coordinate of the second control point.")
    PARM(c2z, real, "z-coordinate of the second control point.")
    PARM(x, real, "x-coordinate of the point to finish to.")
    PARM(y, real, "y-coordinate of the point to finish to.")
    PARM(z, real, "z-coordinate of the point to finish to.")
, RTAO(curveTo(self, c1x, c1y, c1z, c2x, c2y, c2z, x, y, z)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("cubic curveTo"),
    DOC_DESCRIPTION("Add a cubic curveTo to the current path"),, )
PREFIX(MoveRel,  tree,  "move_relative",
    PARM(x,real, "delta to move to on x-axis.")
    PARM(y,real, "delta to move to on y-axis.")
    PARM(z,real, "delta to move to on z-axis.")
, RTAO(moveToRel(self, x, y, z)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("relative moveTo"),
    DOC_DESCRIPTION("Add a relative moveTo"),, )
PREFIX(LineRel,  tree,  "line_relative",
    PARM(x,real, "delta to line to on x-axis.")
    PARM(y,real, "delta to line to on y-axis.")
    PARM(z,real, "delta to line to on z-axis.")
, RTAO(lineToRel(self, x, y, z)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("relative line to"),
    DOC_DESCRIPTION("Add a relative 'lineTo' to the current path"),
    DOC_RET( tree, ""), )
PREFIX(PathTexCoord,  tree,  "path_texture",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(z,real, "z-coordinate")
, RTAO(pathTextureCoord(self, x, y, z)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("Not supported yet"),
    DOC_DESCRIPTION(" NOT SUPPORTED YET. Add a texture coordinate to the path. NOT SUPPORTED YET"),, )
PREFIX(PathColor,  tree,  "path_color",
    PARM(r, real, "The red componant of the color")
    PARM(g, real, "The blue componant of the color")
    PARM(b, real, "The green componant of the color")
    PARM(a, real, "Alpha channel: the transparency of the color. ")
, RTAO(pathColor(self, r,g,b, a)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("Not supported yet"),
    DOC_DESCRIPTION("NOT SUPPORTED YET. Add a color element to the path. NOT SUPPORTED YET. "),, )
PREFIX(ClosePath,  tree,  "close_path", , RTAO(closePath(self)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("close the path"),
    DOC_DESCRIPTION("Close the path back to its origin"),, )
PREFIX(EndpointsStyle,  tree,  "endpoints_style",
    PARM(s, symbol, "start endpoint style")
    PARM(e, symbol, "end endpoint style")
, RTAO(endpointsStyle(self, s, e)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("style of the path endpoints"),
    DOC_DESCRIPTION("Specify the style of the path endpoints. Supported values are : ARROWHEAD, ARROWHEAD, POINTER, DIAMOND, CIRCLE, SQUARE, BAR, CUP, FLETCHING, HOLLOW_CIRCLE, HOLLOW_SQUARE."),
    DOC_RET( tree, ""), )



// ============================================================================
//
//   2D primitives (either standalone, or added to the current path)
//
// ============================================================================

PREFIX(Point,  tree,  "point",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(z,real, "z-coordinate")
    PARM(s,real, "THe size of the point")
, RTAO(fixedSizePoint(self, x, y, z, s)),
    DOC_GROUP(graph:path),
    DOC_SYNOPSIS("Draw a point"),
    DOC_DESCRIPTION("Draw a point with the given size"),, )
PREFIX(Rectangle,  tree,  "rectangle",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width of the rectangle")
    PARM(h,real, "height of the rectangle")
, RTAO(rectangle(self, x, y, w, h)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Draw a rectangle"),
    DOC_DESCRIPTION("Draw a rectangle"),, )
PREFIX(Triangle,  tree,  "triangle",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "base of the triangle")
    PARM(h,real, "height of the triangle")
, RTAO(isoscelesTriangle(self, x, y, w, h)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Isocele triangle"),
    DOC_DESCRIPTION("Draw an isocele triangle"),, )
PREFIX(RightTriangle,  tree,  "right_triangle",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "base of the triangle")
    PARM(h,real, "height of the triangle")
, RTAO(rightTriangle(self, x, y, w, h)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Right triangle"),
    DOC_DESCRIPTION("Draw a right triangle"),, )
PREFIX(Ellipse,  tree,  "ellipse",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width of the ellipse")
    PARM(h,real, "height of the ellipse")
, RTAO(ellipse(self, x, y, w, h)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Ellipse"),
    DOC_DESCRIPTION("Draw an ellipse centered around (cx,cy), size w * h"),, )
PREFIX(EllipseArc,  tree,  "ellipse_arc",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width of the ellipse")
    PARM(h,real, "height of the ellipse")
    PARM(start, real, "start angle")
    PARM(sweep, real, "sweep angle")
, RTAO(ellipseArc(self, x, y, w, h, start, sweep)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Elliptic sector"),
    DOC_DESCRIPTION("Elliptic sector centered around (cx,cy) that occupies the given rectangle, beginning at the specified startAngle and extending sweepLength degrees counter-clockwise. Angles are specified in degrees. Clockwise arcs can be specified using negative angles."),, )
PREFIX(RoundedRectangle,  tree,  "rounded_rectangle",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width of the rectangle")
    PARM(h,real, "height of the rectangle")
    PARM(r, real, "corner radius")
, RTAO(roundedRectangle(self, x, y, w, h, r)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Rounded rectangle"),
    DOC_DESCRIPTION("Rounded rectangle with radius r for the rounded corners"),, )
PREFIX(EllipticalRectangle,  tree,  "elliptical_rectangle",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width of the rectangle")
    PARM(h,real, "height of the rectangle")
    PARM(r, real, "ration of the ellpitic sides")
, RTAO(ellipticalRectangle(self, x, y, w, h, r)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Elliptical rectangle"),
    DOC_DESCRIPTION("Elliptical rectangle with ratio r for the elliptic sides"),, )
PREFIX(Arrow,  tree,  "arrow",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width of  [TODO: what ?]")
    PARM(h,real, "height of [TODO: what ?]")
    PARM(ax, real, "[TODO]")
    PARM(ay, real, "[TODO]")
, RTAO(arrow(self, x, y, w, h, ax, ay)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Draw an arraw"),
    DOC_DESCRIPTION("Draw an arraw"),, )
PREFIX(DoubleArrow,  tree,  "double_arrow",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width of  [TODO: what ?]")
    PARM(h,real, "height of [TODO: what ?]")
    PARM(ax, real, "[TODO]")
    PARM(ay, real, "[TODO]")
, RTAO(doubleArrow(self, x, y, w, h, ax, ay)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Double arraw"),
    DOC_DESCRIPTION("Draw a symetric double arraw"),, )
PREFIX(StarPolygon,  tree,  "star_polygon",
    PARM(x, real, "center x-coordinate")
    PARM(y, real, "center y-coordinate")
    PARM(w, real, "width of the star")
    PARM(h, real, "height of the star")
    PARM(p, integer, "Number of branch[TODO: is OK?]")
    PARM(q, integer, "[TODO]")
, RTAO(starPolygon(self, x, y, w, h, p, q)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Draw a star"),
    DOC_DESCRIPTION("GL regular p-side star polygon {p/q} centered around (cx,cy)"),, )
PREFIX(Star,  tree,  "star",
    PARM(x, real, "center x-coordinate")
    PARM(y, real, "center y-coordinate")
    PARM(w, real, "width of the star")
    PARM(h, real, "height of the star")
    PARM(p, integer, "Number of branch[TODO: is OK?]")
    PARM(r, real, "inner radius ratio")
, RTAO(star(self, x, y, w, h, p, r)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Draw a star"),
    DOC_DESCRIPTION("GL regular p-side star centered around (cx,cy), inner radius ratio r"),, )
PREFIX(SpeechBalloon,  tree,  "speech_balloon",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(w, real, "width of the balloon")
    PARM(h, real, "height of the balloon")
    PARM(r, real, "radius")
    PARM(ax, real, "[TODO]")
    PARM(ay, real, "[TODO]")
, RTAO(speechBalloon(self, x, y, w, h, r, ax, ay)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("Speech balloon"),
    DOC_DESCRIPTION("Speech balloon with radius r for rounded corners, and point a for the tail"),, )
PREFIX(Callout,  tree,  "callout",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(w, real, "width of the callout")
    PARM(h, real, "height of the callout")
    PARM(r, real, "radius")
    PARM(ax, real, "x-coordinate of point a")
    PARM(ay, real, "y-coordinate of point a")
    PARM(d, real, "[TODO]")
, RTAO(callout(self, x, y, w, h, r, ax, ay, d)),
    DOC_GROUP(graph:path:shape),
    DOC_SYNOPSIS("callout"),
    DOC_DESCRIPTION("Callout with radius r for corners, and point a, width b [TODO: is d or b] for the tail"),, )

PREFIX(PicturePacker,  tree,  "picture_packer",
    PARM(tw, integer, "width")
    PARM(th, integer, "height")
    PARM(iw, integer, "[TODO]")
    PARM(ih, integer, )
    PARM(pw, integer, )
    PARM(ph, integer, )
    PARM(t, tree, )
, RTAO(picturePacker(self, tw, th, iw, ih, pw, ph, t)),
    DOC_GROUP(graph:debug),
    DOC_SYNOPSIS("Debug the bin packer"),
    DOC_DESCRIPTION("Debug the bin packer"),, )



// ============================================================================
//
//   3D primitives
//
// ============================================================================

PREFIX(Sphere,  tree,  "sphere",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(z, real, "z-coordinate")
    PARM(w, real, "width")
    PARM(h, real, "height")
    PARM(d, real, "depth")
    PARM(slices, integer, "number of slices")
    PARM(stacks, integer, "[TODO]")
, RTAO(sphere(self, x, y, z, w, h, d, slices, stacks)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("sphere like"),
    DOC_DESCRIPTION("GL sphere [TODO or ovoid ? Add the incidence of slices and stacks on the sphere rendering time.]"),
    DOC_RET( tree, ""), )
PREFIX(Cube,  tree,  "cube",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(z, real, "z-coordinate")
    PARM(w, real, "width")
    PARM(h, real, "height")
    PARM(d, real, "depth")
, RTAO(cube(self, x, y, z, w, h, d)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("cube like"),
    DOC_DESCRIPTION("parallelepiped rectangle"),, )
PREFIX(Cone,  tree,  "cone",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(z, real, "z-coordinate")
    PARM(w, real, "width")
    PARM(h, real, "height")
    PARM(d, real, "depth")
, RTAO(cone(self, x, y, z, w, h, d, 0.0)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("cone"),
    DOC_DESCRIPTION("cone[TODO]"),, )
PREFIX(Cylinder,  tree,  "cylinder",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(z, real, "z-coordinate")
    PARM(w, real, "width")
    PARM(h, real, "height")
    PARM(d, real, "depth")
, RTAO(cone(self, x, y, z, w, h, d, 1.0)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("cone"),
    DOC_DESCRIPTION("cone[TODO]"),, )
PREFIX(TruncatedCone,  tree,  "truncated_cone",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(z, real, "z-coordinate")
    PARM(w, real, "width")
    PARM(h, real, "height")
    PARM(d, real, "depth")
    PARM(r, real, )
, RTAO(cone(self, x, y, z, w, h, d, r)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("cone"),
    DOC_DESCRIPTION("cone[TODO]"),, )
PREFIX(Object3D,  tree,  "object",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(z, real, "z-coordinate")
    PARM(w, real, "width")
    PARM(h, real, "height")
    PARM(d, real, "depth")
    PARM(f, text, "filename")
, RTAO(object(self, x, y, z, w, h, d, f)),
    DOC_GROUP(graph),
    DOC_SYNOPSIS("Load a 3D object"),
    DOC_DESCRIPTION("Load a 3D object [TODO: which format of file can be loaded ?"),, )



// ============================================================================
//
//   Text and font
//
// ============================================================================

PREFIX(TextBox,  tree,  "text_box",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(w, real, "width")
    PARM(h, real, "height")
    PARM(t, tree, "text description")
, RTAO(textBox(self, x, y, w, h, t)),
    DOC_GROUP(text:graph),
    DOC_SYNOPSIS("Create a new page layout"),
    DOC_DESCRIPTION("Create a new page layout and render text in it."),
    DOC_RET( tree, "t evaluation result"), )
PREFIX(TextOverflow,  tree,  "text_overflow",
    PARM(x, real, "x-coordinate")
    PARM(y, real, "y-coordinate")
    PARM(w, real, "width")
    PARM(h, real, "height")
, RTAO(textOverflow(self, x, y, w, h)),
    DOC_GROUP(text:graph),
    DOC_SYNOPSIS("Overflow text box"),
    DOC_DESCRIPTION("Overflow text box for the rest of the current text flow"),, )
PREFIX(TextFlow,  tree,  "text_flow",
    PARM(n, text, "The name of the current flow")
, RTAO(textFlow(self, n)),
    DOC_GROUP(text),
    DOC_SYNOPSIS("Names the flow"),
    DOC_DESCRIPTION("Set the name of the current text flow"),
    DOC_RET( tree, "The previous name. [TODO: The name of the previous flow or the previous name of the current flow ?]"), )

PREFIX(TextSpan,  tree, "text",
    PARM(t, text, "The text to insert")
, RTAO(textSpan(self, t)),
    DOC_GROUP(text),
    DOC_SYNOPSIS("Insert a block of text"),
    DOC_DESCRIPTION("Insert a block of text with the current definition of font, color, ..."),, )
PREFIX(TextFormula,  tree, "formula",
    PARM(t, tree, "The formula")
, RTAO(textFormula(self, t)),
    DOC_GROUP(text),
    DOC_SYNOPSIS("Insert a block of text corresponding to the given formula"),
    DOC_DESCRIPTION("Insert a block of text corresponding to the given formula"),
    DOC_RET( tree, "The tree t given in parameter."), )
PREFIX(TextValue,  tree, "text_value",
    PARM(t, tree, "The formula")
, RTAO(textValue(self, &t)),
    DOC_GROUP(text),
    DOC_SYNOPSIS("Insert a block of text corresponding to the given vaue"),
    DOC_DESCRIPTION("Insert a block of text corresponding to the given formula"),
    DOC_RET( tree, "The tree t given in parameter."), )
PREFIX(Font,  tree,  "font",
    PARM(f, tree, "The font description")
, RTAO(font(self, f)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Select a font family"),
    DOC_DESCRIPTION("Select a font family"),, )
PREFIX(FontSize,  tree,  "font_size",
    PARM(s, real, "The font size.")
, RTAO(fontSize(self, s)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Select a font size"),
    DOC_DESCRIPTION("Select a font size"),, )
PREFIX(FontScaling,  tree,  "font_scaling",
    PARM(s,real, "Scaling factor")
    PARM(ms,real, "Minimum AA size")
, RTAO(fontScaling(self,s,ms)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Change the font scaling factor"),
    DOC_DESCRIPTION("Change the font scaling factor"),
    DOC_RET( tree, ""), )
PREFIX(FontPlain,  tree,  "plain", , RTAO(fontPlain(self)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Set plain text"),
    DOC_DESCRIPTION("Reset the font style, the font weight and the font stretch to normal; reset the font to no underline, nor strikeout, nor overline."),, )
PREFIX(FontSlant,  tree,  "slant",
    PARM(a, real, "slant percentage")
, RTAO(fontItalic(self, a/100)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Set slant percentage."),
    DOC_DESCRIPTION("Set slant percentage.[TODO: J'aurais plutot vu une valeur de a/50 pour que slant 100 donne fontItalic 2, qui est le max] "),, )
PREFIX(FontRoman,  tree,  "roman", , RTAO(fontItalic(self, 0)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("No slant"),
    DOC_DESCRIPTION("Set slant value to 0 (min value)."),, )
PREFIX(FontItalic,  tree,  "italic", , RTAO(fontItalic(self, 1)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("set set italic"),
    DOC_DESCRIPTION("Set slant value to 1 (medium value). Is equivalent to slant 100"),, )
PREFIX(FontOblique,  tree,  "oblique", , RTAO(fontItalic(self, 2)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("set to oblique"),
    DOC_DESCRIPTION("Set slant value to 2 (higher value). Is equivalent to slant 200"),, )
PREFIX(FontWeight,  tree,  "weight",
    PARM(a, real, "The bold value of the font")
, RTAO(fontBold(self, a)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("set the bold value of the font"),
    DOC_DESCRIPTION("Select whether the font is bold or not. Qt weight values range from 0 to 99 with 50 = regular"),, )
PREFIX(FontRegular,  tree,  "regular", , RTAO(fontBold(self, 50)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("reset bold value to neutral."),
    DOC_DESCRIPTION("Reset bold value to neutral. Is equivalent to weight 50."),, )
PREFIX(FontLight,  tree,  "light", , RTAO(fontBold(self, 25)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Make the font thin."),
    DOC_DESCRIPTION("Make the font thinner. Is equivalent to weight 25"),, )
PREFIX(FontBold,  tree,  "bold", , RTAO(fontBold(self, 75)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Make the font bold."),
    DOC_DESCRIPTION("Make the font bold. Is equivalent to weight 75"),, )
PREFIX(FontUnderline,  tree,  "underline",
    PARM(a, real, "Underline values: 0 is off, values > 0 are on.")
, RTAO(fontUnderline(self, a)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Underline attribute of the font"),
    DOC_DESCRIPTION("Select whether we underline a font. Qt doesn't support setting the size of the underline, it's on or off."),, )
PREFIX(FontOverline,  tree,  "overline",
    PARM(a, real, "Overline values: 0 is off, values > 0 are on.")
, RTAO(fontOverline(self, a)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Overline attribute of the font"),
    DOC_DESCRIPTION("Select whether we overline a font. Qt doesn't support setting the size of the underline, it's on or off."),, )
PREFIX(FontStrikeout,  tree,  "strikeout",
    PARM(a, real, "Strikeout values: 0 is off, values > 0 are on.")
, RTAO(fontStrikeout(self, a)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Strikeout attribute of the font"),
    DOC_DESCRIPTION("Select whether we strikeout a font. Qt doesn't support setting the size of the underline, it's on or off."),, )
PREFIX(FontStretch,  tree,  "stretch",
    PARM(s,real, "The font stretching factor. Value range is from 0 to 4000, with 100 = 100%")
, RTAO(fontStretch(self,s)),
    DOC_GROUP(text:font),
    DOC_SYNOPSIS("Set font stretching factor"),
    DOC_DESCRIPTION("Set font stretching factor. Qt font stretch ranges from 0 to 4000, with 100 = 100%."),, )
PREFIX(Align,  tree,  "align",
    PARM(center, real, "Place the center along x-axis. An amount of 0% align the center of the text on the left of the box, an amount of 100% align the center of the text on the right of the box and an amount of 50% align the center of the text on the center of the box.")
    PARM(justify, real, "Horizontaly justify the text. An amount of 0% doesn't justify (ragged edge), an amount of 100% justifies fully.")
    PARM(spread, real, "[TODO: Quel est la difference entre spread et justify ? Est-ce l'ecart max autorise entre les lettres/mots ?]")
    PARM(full_justify, real, "Horizontaly justify the text in lines that do not have enough characters, typically the last line of a paragraph.")
, RTAO(align(self, center, justify, spread, full_justify, 0)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("[TODO]"),
    DOC_DESCRIPTION("[TODO]"),, )
PREFIX(VAlign,  tree,  "vertical_align",
    PARM(center, real, "Place the center along y-axis. An amount of 0% aligns the center of the text on the top of the box, an amount of 100% aligns the center of the text on the bottom of the box and an amount of 50% centers the text in the box.")
    PARM(justify, real, "Verticaly justify the text. An amount of 0% doesn't justify (pack lines), an amount of 100% fully justifies vertically.")
    PARM(spread, real, "[TODO]")
    PARM(full_justify, real, "Vertically justify the lines in text boxes or overflows that are not full.")
, RTAO(align(self, center, justify, spread, full_justify, 1)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("[TODO]"),
    DOC_DESCRIPTION("[TODO]"),, )
PREFIX(Spacing,  tree,  "character_spacing",
    PARM(factor, real, "[TODO]")
, RTAO(spacing(self, factor, 0)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("[TODO]"),
    DOC_DESCRIPTION("[TODO]"),, )
PREFIX(VSpacing,  tree,  "line_spacing",
    PARM(factor, real, "[TODO]")
, RTAO(spacing(self, factor, 1)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("[TODO]"),
    DOC_DESCRIPTION("[TODO]"),, )
PREFIX(MinimumParagraphSpace,  tree,  "paragraph_space",
    PARM(b, real, "Space before the paragraph.")
    PARM(a, real, "Space after the paragraph.")
, RTAO(minimumSpace(self, b, a, 1)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("Set the space around the paragraph"),
    DOC_DESCRIPTION("Set the minimum space allowed around the paragraph. [TODO: Quelle valeur faut-il mettre si on ne veut modifier que la valeur avant (ou apres), est-ce -1, ou est-ce que des valeurs negatives sont autorisees et que dans ce cas des paragraphes peuvent se marcher dessus ?]"),, )
PREFIX(MinimumCharacterSpace,  tree,  "character_space",
    PARM(b, real, "Space before the [TODO].")
    PARM(a, real, "Space after the [TODO].")
, RTAO(minimumSpace(self, b, a, 0)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("[TODO: words or characters ?]"),
    DOC_DESCRIPTION("[TODO: dans widget.cpp on parle d'espace entre mots et non entre charactere. Cette clarification rejoint celles demandees audessus sur le spacing/spread]"),, )
PREFIX(Margins,  tree,  "margins",
    PARM(l, real, "left margin")
    PARM(r, real, "right margin")
, RTAO(horizontalMargins(self, l, r)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("Set the horizontal margin for text"),
    DOC_DESCRIPTION("Set the minimum space allowed around the page. [TODO: Quelle valeur faut-il mettre si on ne veut modifier que la valeur gauche (ou droite), est-ce -1, ou est-ce que des valeurs negatives sont autorisees et que dans ce cas on peut ecrire dans la marge ?]"),, )
PREFIX(VMargins,  tree,  "vertical_margins",
    PARM(t, real, "top margin")
    PARM(b, real, "bottom margin")
, RTAO(verticalMargins(self, t, b)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("Set the vertical margin for text"),
    DOC_DESCRIPTION("Set the minimum space allowed around the page. [TODO: Quelle valeur faut-il mettre si on ne veut modifier que la valeur gauche (ou droite), est-ce -1, ou est-ce que des valeurs negatives sont autorisees et que dans ce cas on peut ecrire dans la marge ?]"),, )
PREFIX(LineBreak,  tree,  "line_break", , RTAO(drawingBreak(self, Tao::Drawing::LineBreak)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("Insert a line break"),
    DOC_DESCRIPTION("Insert a line break in the current text."),, )
PREFIX(SentenceBreak,  tree,  "sentence_break", , RTAO(drawingBreak(self, Tao::Drawing::SentenceBreak)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("Insert a sentence break"),
    DOC_DESCRIPTION("Insert a sentence break in the text."),, )
PREFIX(ParaBreak,  tree,  "paragraph_break", , RTAO(drawingBreak(self, Tao::Drawing::ParaBreak)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("Insert a paragraph break"),
    DOC_DESCRIPTION("Insert a paragraph break"),, )
PREFIX(ColumnBreak,  tree,  "column_break", , RTAO(drawingBreak(self, Tao::Drawing::ColumnBreak)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("Insert a column break"),
    DOC_DESCRIPTION("Insert a column break[TODO]"),, )
PREFIX(PageBreak,  tree,  "page_break", , RTAO(drawingBreak(self, Tao::Drawing::PageBreak)),
    DOC_GROUP(text:spread),
    DOC_SYNOPSIS("Insert a page break"),
    DOC_DESCRIPTION("Insert a page break. [TODO]"),, )
PREFIX(TextEditKey,  boolean,  "text_edit_key",
    PARM(k, text, "key name")
, RTAO(textEditKey(self, k)),
    DOC_GROUP(text),
    DOC_SYNOPSIS("[TODO]"),
    DOC_DESCRIPTION("Send a key to the text editing activities. [TODO: Concretement, ca fait quoi ???]"),
    DOC_RET( boolean, "true/false [TODO]"), )
PREFIX(LoadText,  tree,  "load_text",
    PARM(f,text, "file name")
, RTAO(loadText(self,f)),
    DOC_GROUP(text:file),
    DOC_SYNOPSIS("Load a text file from disk"),
    DOC_DESCRIPTION("Load a text file from disk. It uses the 'doc' prefix to look into resources"),
    DOC_RET( tree, "The content of the file."), )
PREFIX(TaoVersion,  tree,  "tao_version", , RTAO(taoVersion(self)),
    DOC_GROUP(version),
    DOC_SYNOPSIS("The Tao version"),
    DOC_DESCRIPTION("Return the version of the Tao program"),
    DOC_RET( tree, "The version of the running Tao program"), )
PREFIX(DocVersion,  tree,  "doc_version", , RTAO(docVersion(self)),
    DOC_GROUP(version),
    DOC_SYNOPSIS("The document version"),
    DOC_DESCRIPTION("Return the version of the current document (if known)"),
    DOC_RET( tree, "The current document version"), )



// ============================================================================
//
//   Tables
//
// ============================================================================

PREFIX(NewTableAt,  tree,  "table",
    PARM(x,real, )
    PARM(y, real, )
    PARM(r,integer, )
    PARM(c,integer, )
    PARM(b,tree, )
, RTAO(newTable(self, x, y, r, c, b)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(NewTable,  tree,  "table",
    PARM(r,integer, "x-coordinate of the table. 0 if not specified.")
    PARM(c,integer, "y-coordinate of the table. 0 if not specified.")
    PARM(b,tree, "The number of row")
, RTAO(newTable(self, r, c, b)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("Create a table"),
    DOC_DESCRIPTION("Create a new table. The body is executed in the environement of the table, that means short name can be used for table description"),
    DOC_RET( tree, "The result of the body (b) evaluation."), )
PREFIX(TableSizedCell,  tree,  "table_cell",
    PARM(w, real, )
    PARM(h, real, )
    PARM(b, tree, )
, RTAO(tableCell(self, w, h, b)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(TableCell,  tree,  "table_cell",
    PARM(b, tree, "width of the cell if specified, otherwise free size.")
, RTAO(tableCell(self, b)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("Define a free-size cell in the table"),
    DOC_DESCRIPTION("Define a cell in the context of the table. Short name 'cell' can be used with both syntaxes."),
    DOC_RET( tree, "body evaluation result"),
    DOC_MISC("                err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableMargins2,  tree,  "table_cell_margins",
    PARM(w, real, )
    PARM(h, real, )
, RTAO(tableMargins(self, w, h)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(TableMargins,  tree,  "table_cell_margins",
    PARM(x, real, "x-coordinate of the table. 0 if not specified.")
    PARM(y, real, "y-coordinate of the table. 0 if not specified.")
    PARM(w, real, "width of the cell if specified, otherwise free size.")
    PARM(h, real, "height of the cell if specified, otherwise free size.")
, RTAO(tableMargins(self, x, y, w, h)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("Set the margin rectangle for the table."),
    DOC_DESCRIPTION("Set the margin rectangle for the table. The short name of the function is margins. It can be used with both syntaxes."),,
    DOC_MISC("  err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableFill,  tree,  "table_cell_fill",
    PARM(b, tree, "fill code body.")
, RTAO(tableFill(self, b)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("fill of the cell"),
    DOC_DESCRIPTION("Define the fill code for cells"),,
    DOC_MISC("  err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableBorder,  tree,  "table_cell_border",
    PARM(b, tree, "border code body.")
, RTAO(tableBorder(self, b)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("Define the border code for cells"),
    DOC_DESCRIPTION("Define the border code for cells. The short name is border."),,
    DOC_MISC("  err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableCellX,  tree,  "table_cell_x", , RTAO(tableCellX(self)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("x-ccordinate of the cell center"),
    DOC_DESCRIPTION("Get the horizontal center of the current table cell"),
    DOC_RET( tree, "The coordinate of the center of the current cell on x-axis"),
    DOC_MISC("  err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableCellY,  tree,  "table_cell_y", , RTAO(tableCellY(self)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("y-ccordinate of the cell center"),
    DOC_DESCRIPTION("Get the vertical center of the current table cell"),
    DOC_RET( tree, "The coordinate of the center of the current cell on y-axis"), )
PREFIX(TableCellW,  tree,  "table_cell_w", , RTAO(tableCellW(self)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("Width of the cell"),
    DOC_DESCRIPTION("Get the horizontal size of the current table cell"),
    DOC_RET( tree, "The size of the current cell along the x-axis"), )
PREFIX(TableCellH,  tree,  "table_cell_h", , RTAO(tableCellH(self)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("Height of the cell."),
    DOC_DESCRIPTION("Get the vertical size of the current table cell"),
    DOC_RET( tree, "The size of the current cell along the y-axis"),
    DOC_MISC("  err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableRow,  tree,  "table_cell_row", , RTAO(tableRow(self)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("Return the current row"),
    DOC_DESCRIPTION("Return the current row index"),
    DOC_RET( tree, "the row index"),
    DOC_MISC("  err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableColumn,  tree,  "table_cell_column", , RTAO(tableColumn(self)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("Return the current column"),
    DOC_DESCRIPTION("Return the current column index."),
    DOC_RET( tree, "The column index."),
    DOC_MISC("  err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableRows,  tree,  "table_rows", , RTAO(tableRows(self)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("number of rows in the current table"),
    DOC_DESCRIPTION("Return the number of rows in the current table"),
    DOC_RET( tree, "Number of rows in the table"),
    DOC_MISC("                err \"Error raised when invoked outside of a table context.\" \
"))
PREFIX(TableColumns,  tree,  "table_columns", , RTAO(tableColumns(self)),
    DOC_GROUP(table),
    DOC_SYNOPSIS("number of columns in the current table"),
    DOC_DESCRIPTION("Return the number of columns in the current table"),
    DOC_RET( tree, "number of columns in the table"),
    DOC_MISC("  err \"Error raised when invoked outside of a table context.\" \
"))

 

// ============================================================================
//
//   Frames and widgets
//
// ============================================================================

PREFIX(Caption,  tree,  "status",
    PARM(t, text, "The text for the status line.")
, RTAO(status(self, t)),
    DOC_GROUP(gui),
    DOC_SYNOPSIS("Set the status line of the window"),
    DOC_DESCRIPTION("Set the content of the status line of the window"),, )
PREFIX(Frame,  tree,  "frame",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(p, tree, "The program that represent the content of the frame")
, RTAO(framePaint(self, x, y, w, h, p)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("A frame with a content"),
    DOC_DESCRIPTION("Draw a frame with the described content in 'prog'. This frame as no displayed border. It makes a texture of size (w,h) using 'frame_texture', and map it on a rectangle at (x,y) location."),
    DOC_RET( tree, "The result of 'prog' evaluation"), )
PREFIX(FrameTexture,  tree,  "frame_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(p, tree, "The program that represent the content of the frame")
, RTAO(frameTexture(self, w, h, p)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("A texture with content"),
    DOC_DESCRIPTION("Make a texture out of the described content"),
    DOC_RET( tree, "The result of 'prog' evaluation"), )
PREFIX(Url,  tree,  "url",
    PARM(x,real, )
    PARM(y,real, )
    PARM(w,real, )
    PARM(h,real, )
    PARM(u, text, )
, RTAO(urlPaint(self, x, y, w, h, u, NULL)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(UrlProgress,  tree,  "url",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(u, text, "The URL to display")
    PARM(progress, integer, "[out] The progession of the load in output.")
, RTAO(urlPaint(self, x, y, w, h, u, progress)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Draw a web container"),
    DOC_DESCRIPTION("Load from the given URL a web page and draw it. It uses the QT webkit. "),, )
PREFIX(UrlTexture,  tree,  "url_texture",
    PARM(w,real, )
    PARM(h,real, )
    PARM(u, text, )
, RTAO(urlTexture(self, w, h, u, NULL)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(UrlTextureProgress,  tree,  "url_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(u, text, "The URL to display")
    PARM(progress, integer, "The progession of the load. 0 if not provided")
, RTAO(urlTexture(self, w, h, u, progress)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Make a texture out of a given URL"),
    DOC_DESCRIPTION("Load from the given URL a web page and draw it. It uses the QT webkit. "),, )
PREFIX(LineEdit,  tree,  "line_edit",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(u, text, "The text in the line edit widget. It is an in/out parameter.")
, RTAO(lineEdit(self, x, y, w, h, u)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Draw a line editor in the current frame"),
    DOC_DESCRIPTION("A line edit allows the user to enter and edit a single line of plain text with a useful collection of editing functions, including undo and redo, cut and paste, and drag and drop."),, )
PREFIX(LineEditTexture,  tree,  "line_edit_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(u, text, "The text to insert in the line edit widget.")
, RTAO(lineEditTexture(self, w, h, u)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Make a texture out of a given line editor"),
    DOC_DESCRIPTION(""),, )

PREFIX(PushButton,  tree,  "push_button",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(n, text, "Name that uniquely identify this button")
    PARM(l, text, "Label of the button")
    PARM(a, tree, "The action to perform when the button is clicked.")
, RTAO(pushButton(self, x, y, w, h, n, l, a)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("A push button"),
    DOC_DESCRIPTION("Draw a simple push button in the curent frame. The look and feel of the button is platform dependant. "),, )
PREFIX(PushButtonTexture,  tree,  "push_button_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(n, text, "Name that uniquely identify this button")
    PARM(l, text, "Label of the button")
    PARM(a, tree, "The action to perform when the button is clicked.")
, RTAO(pushButtonTexture(self, w, h, n, l, a)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Make a texture out of a given push button"),
    DOC_DESCRIPTION("Make a platform dependant texture out of a given push button"),, )

PREFIX(RadioButton,  tree,  "radio_button",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(n, text, "Name that uniquely identify this button")
    PARM(l, text, "Label of the button")
    PARM(m, text, "True if the button is selected")
    PARM(a, tree, "The action to perform when the button state change from non-selected to selected.")
, RTAO(radioButton(self, x, y, w, h, n, l, m, a)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Draw a radio button"),
    DOC_DESCRIPTION("Draw a radio button in the curent frame. Associate the action to perform when the button state change from non-selected to selected. Radio buttons are mutually exclusive, if you want to have multiple groups of radio button, uses the button_group."),, )
PREFIX(RadioButtonTexture,  tree,  "radio_button_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(n, text, "Name that uniquely identify this button")
    PARM(l, text, "Label of the button")
    PARM(m, text, "True if the button is selected")
    PARM(a, tree, "The action to perform when the button state change from non-selected to selected.")
, RTAO(radioButtonTexture(self, w, h, n, l, m, a)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Make a texture out of a given radio button"),
    DOC_DESCRIPTION("Make a texture out of a given radio button"),, )

PREFIX(CheckBoxButton,  tree,  "check_box_button",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(n, text, "Name that uniquely identify this button")
    PARM(l, text, "Label of the button")
    PARM(m, text, "True if the button is marked")
    PARM(a, tree, "The action to perform when the button state change from non-sed.")
, RTAO(checkBoxButton(self, x, y, w, h, n, l, m, a)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Draw a check button"),
    DOC_DESCRIPTION("Draw a check button in the curent frame"),, )
PREFIX(CheckBoxButtonTexture,  tree,  "check_box_button_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(n, text, "Name that uniquely identify this button")
    PARM(l, text, "Label of the button")
    PARM(m, text, "True if the button is marked")
    PARM(a, tree, "The action to perform when the button state change from non-set to set")
, RTAO(checkBoxButtonTexture(self, w, h, n, l, m, a)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Make a texture out of a given checkbox button"),
    DOC_DESCRIPTION("Make a texture out of a given checkbox button"),, )

PREFIX(ColorChooser,  tree,  "color_chooser",
    PARM(x,real, )
    PARM(y,real, )
    PARM(w,real, )
    PARM(h,real, )
    PARM(t,tree, )
, RTAO(colorChooser(self, x, y, w, h, t)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(ColorChooserNow,  tree,  "color_chooser",
    PARM(n, text, "x-coordinate")
    PARM(t,tree, "y-coordinate")
, RTAO(colorChooser(self, n, t)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Draw a color chooser"),
    DOC_DESCRIPTION("Pop a window with the platform dependant color chooser inside.\
Once the color is chosen Names 'red', 'green', 'blue', and 'alpha' are replaced in the given tree by the corresponding value in the selected color. Then the resulting tree is evaluated.\
 'name' is used to register and uses a color attribute : 'line_color' and 'color' are defined.  "),, )

PREFIX(ColorChooserTexture,  tree,  "color_chooser_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(t,tree, "tree to update with new color")
, RTAO(colorChooserTexture(self, w, h, t)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Make a texture out of a given color chooser"),
    DOC_DESCRIPTION("Make a texture out of a given color chooser"),, )
PREFIX(FontChooserNow,  tree,  "font_chooser",
    PARM(t,tree, )
, RTAO(fontChooser(self, t)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(FontChooser,  tree,  "font_chooser",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(t,tree, "tree to update with new font")
, RTAO(fontChooser(self, x, y, w, h, t)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("font chooser"),
    DOC_DESCRIPTION("Pop a window with the platform dependant font chooser inside. \
Once the font is chosen, Names 'font_family', 'font_size', 'font_weight', 'font_slant', 'font_stretch', 'font_is_italic', and 'font_is_bold' are replaced by their corresponding values in the selected font. The resulting tree is then evaluated."),, )
PREFIX(FontChooserTexture,  tree,  "font_chooser_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(t,tree, "tree to update with new font")
, RTAO(fontChooserTexture(self, w, h, t)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Make a texture out of a given color chooser"),
    DOC_DESCRIPTION("Make a texture out of a given color chooser"),, )
PREFIX(FileChooser,  tree,  "file_chooser",
    PARM(x,real, )
    PARM(y,real, )
    PARM(w,real, )
    PARM(h,real, )
    PARM(t,tree, )
, RTAO(fileChooser(self, x, y, w, h, t)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(FileChooserNow,  tree,  "file_chooser",
    PARM(t,tree, "x-coordinate")
, RTAO(fileChooser(self, t)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Draw a file chooser"),
    DOC_DESCRIPTION("Pop a window with the platform dependant file chooser inside. \
The file_chooser can be parameterized with 4 atributes which are 'action', 'directory', 'label' and 'filter'. Those attributes are defined in the function with file_chooser_ prefix.\
Once the file is selected, Names 'file_name', 'file_directory', 'file_path', and 'rel_file_path' are replaced by their corresponding values from the selected file."),, )
PREFIX(FileChooserTexture,  tree,  "file_chooser_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(t,tree, "tree to update with new file")
, RTAO(fileChooserTexture(self, w, h, t)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Make a texture out of a given file chooser"),
    DOC_DESCRIPTION("Make a texture out of a given file chooser"),, )
PREFIX(SetFileDialogAction,  tree,  "file_chooser_action",
    PARM(t, tree, "The action to modify and execute when file is chosen.")
, RTAO(setFileDialogAction(self, t)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("File chooser action"),
    DOC_DESCRIPTION("Set the action that will be execute when OK is pressed. Only available in a file chooser sub tree."),, )
PREFIX(SetFileDialogDirectory,  tree,  "file_chooser_directory",
    PARM(d, text, "directory name")
, RTAO(setFileDialogDirectory(self, d)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("File chooser directory"),
    DOC_DESCRIPTION("Set the directory to open first. Only available in a file chooser sub tree."),, )
PREFIX(SetFileDialogFilter,  tree,  "file_chooser_filter",
    PARM(d, text, "filter for file")
, RTAO(setFileDialogFilter(self, d)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Set the file filters"),
    DOC_DESCRIPTION("Set the file filters (file pattern, e.g. *.img). Only available in a file chooser sub tree."),, )
PREFIX(SetFileDialogLabel,  tree,  "file_chooser_label",
    PARM(lbl, text, "The label for the file chooser dialog box.")
    PARM(v, text, )
, RTAO(setFileDialogLabel(self, lbl, v)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Set labels on a file dialog"),
    DOC_DESCRIPTION("Set labels on a file dialog. Only available in a file chooser sub tree."),, )

PREFIX(ButtonGroup,  tree,  "button_group",
    PARM(ex, boolean, "If true, the group is exclusive.")
    PARM(b, tree, "The code of buttons")
, RTAO(buttonGroup(self, ex, b)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Create a button group."),
    DOC_DESCRIPTION("Create a group. Buttons included in this group are mutually exclusive. It is useful to create multiple group of radio buttons"),, )

PREFIX(Action,  tree,  "button_group_action",
    PARM(act, tree, "The action.")
, RTAO(setButtonGroupAction(self, act)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Action of the group"),
    DOC_DESCRIPTION("Set the action to be executed by the current buttonGroup.When a button in the group is clicked, this action is triggered as well as the button's action."),, )

PREFIX(GroupBox,  tree,  "group_box",
    PARM(x,real, "x-coordinate of this box")
    PARM(y,real, "y-coordinate of this box")
    PARM(w,real, "width of this box")
    PARM(h,real, "height of this box")
    PARM(lbl, text, "The label of the box")
    PARM(b, tree, "The tree describing the content of the box")
, RTAO(groupBox(self, x, y, w, h, lbl, b)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("group box"),
    DOC_DESCRIPTION("Draw a group box in the current frame. The x and y coordinate of widgets placed in this box are the colomn and row number. Total number of rows and columns is dynamic."),, )
PREFIX(GroupBoxTexture,  tree,  "group_box_texture",
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(lbl, text, "The label of the box")
, RTAO(groupBoxTexture(self, w, h, lbl)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Texture group box."),
    DOC_DESCRIPTION("Make a texture out of a given group box."),, )


PREFIX(Movie,  tree,  "movie",
    PARM(x,real, "x-coordinate")
    PARM(y,real, "y-coordinate")
    PARM(w,real, "width")
    PARM(h,real, "height")
    PARM(u,text, "The URL of the video to play.")
, RTAO(movie(self, x, y, w, h, u)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Play a movie"),
    DOC_DESCRIPTION("Display a movie in the rectangle specified by the given coordinates. Supported movie formats depend on the operating system."),, )
PREFIX(MovieTexture,  tree,  "movie_texture",
    PARM(u,text, "width")
, RTAO(movieTexture(self, u)),
    DOC_GROUP(widget),
    DOC_SYNOPSIS("Create a texture from a video."),
    DOC_DESCRIPTION("Create a dynamic texture from the given movie."),, )



// ============================================================================
//
//   Chooser
//
// ============================================================================

PREFIX(Chooser,  tree,  "chooser",
    PARM(n, text, "The caption of the chooser.")
, RTAO(chooser(self, n)),
    DOC_GROUP(code:chooser),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION("Create a chooser with the given caption. A chooser shows a selection among the possible commands"),, )
PREFIX(ChooserChoice,  tree,  "chooser_choice",
    PARM(n, text, "label of the command")
    PARM(t, tree, "the command")
, RTAO(chooserChoice(self, n, t)),
    DOC_GROUP(code:chooser),
    DOC_SYNOPSIS("Add a command in the chooser list."),
    DOC_DESCRIPTION("Create a chooser item and associate a command"),, )
PREFIX(ChooserCommands,  tree,  "chooser_commands",
    PARM(p, text, "The prefix")
    PARM(t,text, "The label")
, RTAO(chooserCommands(self, p, t)),
    DOC_GROUP(code:chooser),
    DOC_SYNOPSIS("Add all commands from the symbols list."),
    DOC_DESCRIPTION(" Add all commands in the current symbol table that have the given prefix"),, )
PREFIX(ChooserPages,  tree,  "chooser_pages",
    PARM(p, symbol, "The prefix that will be added to the page name")
    PARM(l, text, "The text that will be added as label prefix to the name of pages.")
, RTAO(chooserPages(self, p, l)),
    DOC_GROUP(code:chooser),
    DOC_SYNOPSIS("pages added to the chooser"),
    DOC_DESCRIPTION("Add the list of pages to the chooser"),, )
PREFIX(ChooserBranches,  tree,  "chooser_branches",
    PARM(p, symbol, "The action to execute when branch is selected (will be passed branch name as text)")
    PARM(l, text, "The text that will be added as label prefix to the name of branches.")
, RTAO(chooserBranches(self, p, l)),
    DOC_GROUP(code:chooser),
    DOC_SYNOPSIS("branches added to the chooser"),
    DOC_DESCRIPTION("Add the list of project branches to the chooser"),, )
PREFIX(ChooserCommits,  tree,  "chooser_commits",
    PARM(b, text, "The branch name")
    PARM(p, symbol, "The action to execute when commit is selected (will be passed commit ID as text)")
    PARM(l, text, "The text that will be added as label prefix to the commit log.")
, RTAO(chooserCommits(self, b, p, l)),
    DOC_GROUP(code:chooser),
    DOC_SYNOPSIS("commits added to the chooser"),
    DOC_DESCRIPTION("Add the branch history (commits) to the chooser"),, )
PREFIX(Checkout,  tree,  "checkout",
    PARM(t, text, "The name of the branch, or the commit ID, to checkout.")
, RTAO(checkout(self, t)),
    DOC_GROUP(code:checkout),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION("Checkout a branch or a commit"),, )



// ============================================================================
//
//    Menus
//
// ============================================================================

PREFIX(Menu,  tree,  "menu",
    PARM(n, text, "Name that uniquely identify this menu")
    PARM(lbl, text, "The label of the menu")
    PARM(icon, text, "The name of the icon (filename).")
, RTAO(menu(self, n, lbl, icon, false)),
    DOC_GROUP(widget:menu),
    DOC_SYNOPSIS("Create/Select a menu"),
    DOC_DESCRIPTION("Add the menu to the current menu bar or create the contextual menu. If the menu already exist, it is updated and set as the current menu"),, )

PREFIX(SubMenu,  tree,  "submenu",
    PARM(name, text, "Name that uniquely identify this menu")
    PARM(lbl, text, "The label of the menu")
    PARM(icon, text, "The name of the icon (filename).")
, RTAO(menu(self, name, lbl, icon, true)),
    DOC_GROUP(widget:menu),
    DOC_SYNOPSIS("Create/Select a submenu"),
    DOC_DESCRIPTION("Add the submenu to the current menu. If the submenu already exist, it is updated and set as the current menu"),, )

PREFIX(MenuItem,  tree,  "menu_item",
    PARM(n, text, "Name that uniquely identify this entry")
    PARM(lbl, text, "The label of the entry")
    PARM(icon, text, "The name of the icon (filename).")
    PARM(cable, boolean, "Should this entry carry a check box ?")
    PARM(isc, text, "If this entry carries a check box, is it cheked or not.")
    PARM(t, tree, "The command to execute on item selection.")
, RTAO(menuItem(self, n, lbl, icon, cable, isc, t)),
    DOC_GROUP(widget:menu),
    DOC_SYNOPSIS("add an entry in a menu"),
    DOC_DESCRIPTION("Add an entry in the current menu with the label, icon, checkmark and command."),, )

PREFIX(ToolBar,  tree,  "toolbar",
    PARM(name, text, "Name that uniquely identify this toolbar")
    PARM(lbl, text, "The label of the toolbar")
    PARM(loc, text, "The location of the toolbar in the widget. Supported values are [n|N]*, [e|E]*, [s|S]*, [w|W|o|O]*")
, RTAO(toolBar(self, name, lbl, true, loc)),
    DOC_GROUP(widget:menu),
    DOC_SYNOPSIS("Add the toolBar"),
    DOC_DESCRIPTION("Add the toolBar to the current widget at the specify location."),, )

PREFIX(MenuBar,  tree,  "menubar", , RTAO(menuBar(self)),
    DOC_GROUP(widget:menu),
    DOC_SYNOPSIS("Set the current menubar"),
    DOC_DESCRIPTION("Set the current menubar to the default menuBar"),, )

PREFIX(Separator,  tree,  "separator", , RTAO(separator(self)),
    DOC_GROUP(widget:menu),
    DOC_SYNOPSIS("Add a separator"),
    DOC_DESCRIPTION("Add a separator to the current menu or menu bar or tool bar. "),, )


// ============================================================================
//
//   Error management
//
// ============================================================================

PREFIX(ErrorMessage,  tree,  "error",
    PARM(m, text, )
    PARM(s, tree, )
, return Tao::Widget::runtimeError(self, m, s),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(ErrorMessage0,  tree,  "error",
    PARM(m, text, "The message to display")
, return Tao::Widget::runtimeError(self, m, NULL),
    DOC_GROUP(),
    DOC_SYNOPSIS("Display an error message from the input"),
    DOC_DESCRIPTION("Display an error message from the input"),
    DOC_RET( tree, "[TODO]"), )



// ============================================================================
//
//   Tree management
//
// ============================================================================
PREFIX(Insert0,  boolean,  "insert",
    PARM(m, text, )
    PARM(t, tree, )
, RTAO(insert(self, t, m)),
    DOC_GROUP(),
    DOC_SYNOPSIS(""),
    DOC_DESCRIPTION(""),, )
PREFIX(Insert,  boolean,  "insert",
    PARM(t, tree, "message used to mark the change in the version management tool (git). ")
, RTAO(insert(self, t)),
    DOC_GROUP(tree),
    DOC_SYNOPSIS("Insert code"),
    DOC_DESCRIPTION("Insert at the end of page or program"),, )
PREFIX(Delete,  boolean,  "delete_selection",
    PARM(k, text, "key [TODO]")
, RTAO(deleteSelection(self, k)),
    DOC_GROUP(tree),
    DOC_SYNOPSIS("Delete the selection"),
    DOC_DESCRIPTION("Delete the selection (with text support)"),, )
PREFIX(SetAttribute,  boolean,  "set_attribute",
    PARM(n, text, "Attribute name")
    PARM(t, tree, "Attribute value ")
, RTAO(setAttribute(self, n, t, "group,shape")),
    DOC_GROUP(tree),
    DOC_SYNOPSIS("set attribute is selection"),
    DOC_DESCRIPTION("Insert the tree in all shapes in the selection"),, )


// ============================================================================
//
//   z order management
//
// ============================================================================

PREFIX(BringToFront,  boolean,  "bring_to_front", , RTAO(bringToFront(self)),
    DOC_GROUP(code:zorder),
    DOC_SYNOPSIS("Bring the selected shape to front"),
    DOC_DESCRIPTION("Bring the selected shape to front. This moves the source code of the selection to the end of the page or program"),, )
PREFIX(BringForward,  boolean,  "bring_forward", , RTAO(bringForward(self)),
    DOC_GROUP(code:zorder),
    DOC_SYNOPSIS("Bring the selection one forward"),
    DOC_DESCRIPTION("Swap the selected shape and the one in front of it. This is done by swaping code in the source."),, )
PREFIX(SendToBack,  boolean,  "send_to_back", , RTAO(sendToBack(self)),
    DOC_GROUP(code:zorder),
    DOC_SYNOPSIS("Send the selected shape to back"),
    DOC_DESCRIPTION("Send the selected shape to back. This moves the source code of the selection to the begining of the page or program"),, )
PREFIX(SendBackward,  boolean,  "send_backward", , RTAO(sendBackward(self)),
    DOC_GROUP(code:zorder),
    DOC_SYNOPSIS("Send the selection one backward"),
    DOC_DESCRIPTION("Swap the selected shape and the one just behind it. This is done by swaping code in the source."),, )

// ============================================================================
//
//   group management
//
// ============================================================================

PREFIX(Group,  tree,  "group",
    PARM(t, tree, "The code to group")
, RTAO(group(self, t)),
    DOC_GROUP(code:group),
    DOC_SYNOPSIS("Create a logical group"),
    DOC_DESCRIPTION("Group objects together, make them selectable as a whole."),, )
PREFIX(GroupSelection,  boolean,  "group_selection", , RTAO(groupSelection(self)),
    DOC_GROUP(code:group),
    DOC_SYNOPSIS("Create the group from the selected objects"),
    DOC_DESCRIPTION("Modify the source code to group the selection."),, )
PREFIX(UngroupSelection,  boolean,  "ungroup_selection", , RTAO(ungroupSelection(self)),
    DOC_GROUP(code:group),
    DOC_SYNOPSIS("ungroup the selected group"),
    DOC_DESCRIPTION("Modify the source code to ungroup the selection"),, )

// ============================================================================
//
//   Unit conversions
//
// ============================================================================

POSTFIX(FromCm,    real,
    PARM(x, real, "The value in cm")
,  "cm", RTAO(fromCm(self, x)),
    DOC_GROUP(code:unit),
    DOC_SYNOPSIS("Convert from cm to pixels"),
    DOC_DESCRIPTION("Convert from cm to pixels"),
    DOC_RET(   real, "The value in pixel. "), )
POSTFIX(FromMm,    real,
    PARM(x, real, "The value in mm")
,  "mm", RTAO(fromMm(self, x)),
    DOC_GROUP(code:unit),
    DOC_SYNOPSIS("Convert from mm to pixels"),
    DOC_DESCRIPTION("Convert from mm to pixels"),
    DOC_RET(   real, "The value in pixel. "), )
POSTFIX(FromInch,  real,
    PARM(x, real, "The value in inch")
,  "inch", RTAO(fromIn(self, x)),
    DOC_GROUP(code:unit),
    DOC_SYNOPSIS("Convert from inch to pixels"),
    DOC_DESCRIPTION("Convert from inch to pixels"),
    DOC_RET( real, "The value in pixel. "), )
POSTFIX(FromPt,    real,
    PARM(x, real, "The value in point")
,  "pt", RTAO(fromPt(self, x)),
    DOC_GROUP(code:unit),
    DOC_SYNOPSIS("Convert from pt to pixels"),
    DOC_DESCRIPTION("Convert from pt to pixels"),
    DOC_RET(   real, "The value in pixel. "), )
POSTFIX(FromPx,    real,
    PARM(x, real, "The value in pixel")
,  "px", RTAO(fromPx(self, x)),
    DOC_GROUP(code:unit),
    DOC_SYNOPSIS("Convert from pixel"),
    DOC_DESCRIPTION("Convert from pixel (currently 1-1 mapping, could be based on scaling?)"),
    DOC_RET(   real, "The value in pixel. "), )



// ============================================================================
//
//   Misc...
//
// ============================================================================

PREFIX(Constant,  tree,  "constant",
    PARM(t, tree, "the tree that is constant")
, RTAO(constant(self, t)),
    DOC_GROUP(code),
    DOC_SYNOPSIS("a constant tree"),
    DOC_DESCRIPTION("A tree that cannot be modify."),
    DOC_RET( tree, "the tree"), )
PREFIX(GenDoc,  tree,  "generate_doc",
    PARM(t, tree, "The tree from wich extracting the documentation")
, RTAO(generateDoc(self, t)),
    DOC_GROUP(documentation),
    DOC_SYNOPSIS("generate the doc for the specified tree "),
    DOC_DESCRIPTION("Extract the documentation from the specified tree. "),
    DOC_RET( tree, "The Text contains the documentation, ready to be parsed. "), )

PREFIX(GenAllDoc,  tree,  "generate_all_doc",
    PARM(filename, text, "The location where to write the documentation. If empty, no file written. ")
, RTAO(generateAllDoc(self, filename)),
    DOC_GROUP(documentation),
    DOC_SYNOPSIS("generate all the documentation. "),
    DOC_DESCRIPTION("Extract the documentation from the context, the primitive and the current document. It writes the documentation into the specified files if any. "),
    DOC_RET( tree, "The Text contains the documentation, ready to be parsed. "), )



